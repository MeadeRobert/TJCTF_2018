
# This file was *autogenerated* from the file hastad.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_512 = Integer(512); _sage_const_1024 = Integer(1024)
import binascii
import random

'''
	Textbook Hastad Attack Method
'''
def hastad(ciphertexts, moduli, e=_sage_const_3 ):
	if not (len(moduli) == len(ciphertexts) == e):
		raise RuntimeError("Moduli and ciphertext arrays have to be equal in length and contain at least as many elements as e")

	# compute the message using chinese remainder theorem and coppersmith principle
	return crt(ciphertexts, moduli).nth_root(e)
	
'''
	Hastad Attack with linear padding enabled
	(padding via arithmetic addition of const_array)
'''
def linear_padding(ciphertexts, moduli, pad_array, const_array=(), e=_sage_const_3 , eps=_sage_const_1 /_sage_const_8 ):
	if not(len(ciphertexts) == len(moduli) == len(pad_array) == len(const_array) == e):
		raise RuntimeError("Moduli and ciphertext arrays have to be equal in length and contain at least as many elements as e")
		
	'''
	Init placeholder values
	ciphertexts: ciphertext arrays
	T_array: CRT coefficients
	moduli: modulus arrays
	pad_array: linear coefficient of padding applied to message during encryption
	const_array: constant pad added to message during encryption (optional)
	'''
	T_array = [Integer(_sage_const_0 )]*e
	crt_array = [Integer(_sage_const_0 )]*e
	polynomial_array = []
	
	# populate crt and T arrays with appropriate values using CRT
	for i in range(e):
		crt_array = [_sage_const_0 ]*e
		crt_array[i] = _sage_const_1 
		T_array[i] = Integer(crt(crt_array,moduli))
	
	# computer the product of all the crt polynomials
	G = PolynomialRing(Zmod(prod(moduli)), names=('x',)); (x,) = G._first_ngens(1)
	for i in range(e):
		polynomial_array += [T_array[i]*((pad_array[i]*x+const_array[i])**e - Integer(ciphertexts[i]))] # representation of polynomial f(x) = (A*x + b) ^ e - C where (A*x + b) is padding polynomial
		
	# creates a monic polynomial from the sum of the individual polynomials
	g = sum(polynomial_array).monic()
	
	# solve for the roots of this polynomial (solutions to x, the message m)
	roots = g.small_roots(epsilon=eps)
	
	# return value if single root found; otherwise, the task has failed
	return roots[_sage_const_0 ] if len(roots) >= _sage_const_1  else -_sage_const_1 
	
def convert_to_int(message):
	m = 0L
	for i in message:
		print i
		m += ord(i)
		m <<= _sage_const_8 
	return m

#print convert_to_int("asdf _qwer")
	
def decode(message):
	return message.decode("hex")


'''
	Test the function of the non padded hastad attack.
	
	Limitation: does not work with input string m containing
	spaces or similar chars such as '_'
'''	
def test_no_padding(m = convert_to_int("hello")):
	e = _sage_const_3 
	bound = _sage_const_2 **_sage_const_1024 
	ciphertexts = []
	moduli = []
	
	for i in range(e):
		p = random_prime(bound, proof=false)
		q = random_prime(bound, proof=false)
		n = p*q
		c = Integer(pow(m,e,n))
		moduli += [Integer(n)]
		ciphertexts += [c]
		
	assert hastad(ciphertexts,moduli,e) == m
	print("Success! The recovered message is equal to: " + hex(m)[_sage_const_2 :].decode("hex"))
	return _sage_const_0 

'''
	Test the function of the linear padding enabled hastad attack.
	
	Limitation: does not work with input string m containing
	spaces or similar chars such as '_'
'''
def test_linear_padding(m = convert_to_int("solved")):
	moduli = []
	ciphertexts = []
	pad_array = []
	const_array = []
	e = _sage_const_3 
	pad_bound = _sage_const_2 **_sage_const_512 
	prime_bound = _sage_const_2 **_sage_const_1024 
	
	for i in range(e):
		pad = random.randint(_sage_const_0 , pad_bound)
		constant = random.randint(_sage_const_0 , pad_bound)
		pad_array += [pad]
		const_array += [constant]
		p = random_prime(prime_bound, proof=false)
		q = random_prime(prime_bound, proof=false)
		n = p*q
		moduli += [n]
		ciphertexts.append(pow(pad*m + constant,e,n))
		
	assert linear_padding(ciphertexts, moduli, pad_array, const_array) == m
	print("Success! The recovered message is equal to: " + hex(m)[_sage_const_2 :].decode("hex"))
	return _sage_const_0 
	
#test_no_padding()
#test_linear_padding()

